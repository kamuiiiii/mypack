(()=>{"use strict";var e={n:n=>{var t=n&&n.__esModule?()=>n.default:()=>n;return e.d(t,{a:t}),t},d:(n,t)=>{for(var s in t)e.o(t,s)&&!e.o(n,s)&&Object.defineProperty(n,s,{enumerable:!0,get:t[s]})},o:(e,n)=>Object.prototype.hasOwnProperty.call(e,n),r:e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})}},n={};e.r(n),e.d(n,{default:()=>i}),require("core-js/modules/es.array.iterator.js"),require("core-js/modules/es.map.js"),require("core-js/modules/es.object.to-string.js"),require("core-js/modules/es.string.iterator.js"),require("core-js/modules/web.dom-collections.iterator.js"),require("core-js/modules/es.promise.js"),require("core-js/modules/es.array.for-each.js"),require("core-js/modules/es.array.join.js"),require("core-js/modules/es.regexp.exec.js"),require("core-js/modules/es.string.replace.js"),require("core-js/modules/es.array.map.js"),require("core-js/modules/es.array.slice.js");const t=require("fs/promises");var s=e.n(t);const a=require("path");var r=e.n(a);const o=require("@babel/core"),i=class{constructor({entry:e,output:n,filename:t,port:s=8080}){this.assetMap=new Map,this.config={entry:e,output:n,filename:t,port:s}}async createAsset(e){const n=await s().readFile(e,"utf-8"),t=await o.parseAsync(n),a=[];o.traverse(t,{ImportDeclaration:e=>{a.push({path:e.node.source.value,async:!1})},CallExpression:e=>{"Import"===e.node.callee.type&&e.traverse({StringLiteral:({node:e})=>{a.push({path:e.value,async:!0})}})}});let{code:i}=await o.transformFromAstAsync(t,n,{plugins:[r().resolve(__dirname,"../plugins/plugin-transform-module.js")]});const c={},u=r().dirname(e);return a.forEach((e=>{const n=r().join(u,e.path);if(c[e.path]=n,e.async){const t="./"+n.replace(/\//g,"-");i=i.replace(e.path,t)}})),{id:e,dependencies:a,code:i,mapping:c}}async getOrCreateAsset(e,n){let t;return this.assetMap.has(e)?t=this.assetMap.get(e):(t=await this.createAsset(e),this.assetMap.set(e,t)),n&&n.async&&(t.reload=!0),t}async createGraph(e){const n=[],t=[],s=async(e,n)=>{const s=[await this.getOrCreateAsset(e,{async:n})];for(const e of s)for(const n of e.dependencies){const a=e.mapping[n.path];if(n.async)t.push(a);else{const e=await this.getOrCreateAsset(a);s.push(e)}}return s};n.push(await s(e,!1));for(const e of t)n.push(await s(e,!0));return n}generateModules(e){return e.map((e=>this.generateModule(e))).join("\n")}generateModule(e){return`"${e.id}": [\n        function (require, module, exports) {\n          ${e.code}\n        },\n        ${JSON.stringify(e.mapping)},\n      ],`}bundleInitialChunk=e=>{const n=this.generateModules(e),t=`\n      var __webpack_socket__ = new window.WebSocket("ws://localhost:${this.config.port}");\n      __webpack_socket__.onmessage = function (event) {\n        var data = JSON.parse(event.data);\n        if (data.type === "reload") window.location.reload();\n        else if (data.type === "change") {\n          const script = document.createElement('script');\n          script.src = "./hot-update.js";\n          script.onload = function () {\n            if (__webpack_events__.isEmpty(data.id)) {\n              window.location.reload();\n            } else {\n              __webpack_events__.emit(data.id);\n            }\n          }\n          document.body.appendChild(script);\n        };\n      };\n    `,s=`\n      var __webpack_require__ = (chunk_id) => {\n        function require(id) {\n          const [fn, mapping] = __webpack_modules__[id];\n\n          function localRequire(name) {\n            return require(mapping[name]);\n          }\n\n          const module = { exports: {}, hot: {} };\n          module.hot.accept = function (name, callback) {\n            const id = mapping[name];\n            if (__webpack_events__.isEmpty(id)) {\n              __webpack_events__.on(id, callback);\n            }\n          };\n\n          fn(localRequire, module, module.exports);\n\n          return module.exports;\n        }\n        return require(chunk_id);\n      };\n      var __webpack_modules__ = {${n}};\n      __webpack_require__("${this.config.entry}");\n    `;return this.config.port?"\n      var __webpack_events__ = new class {\n        constructor() {\n          this.map = {};\n        }\n\n        on(type, callback) {\n          this.map[type] = this.map[type] || [];\n          let fns = this.map[type];\n          if (!fns.includes(callback)) {\n            fns.push(callback);\n          }\n          return this;\n        }\n\n        emit(type, ...data) {\n          let fns = this.map[type];\n          if (fns) {\n            fns.forEach((fn) => fn(...data))\n          }\n          return this;\n        }\n\n        off(type, callback) {\n          let fns = this.map[type];\n          if (fns) {\n            this.map[type] = fns.filter((fn) => fn !== callback);\n          } else {\n            throw new Error(`Have not '${type}' event`);\n          }\n          return this;\n        }\n\n        isEmpty(type) {\n          return !this.map[type] || this.map[type].length === 0;\n        }\n      }();\n    "+t+s:s};bundleNonInitialChunk(e){return`\n    __webpack_modules__ = {...__webpack_modules__, ${this.generateModules(e)}}\n    export default __webpack_require__("${e[0].id}");\n  `}async bundleUpdateChunk(e){return`\n    __webpack_modules__ = {...__webpack_modules__, ${this.generateModule(e)}}\n  `}async update(e){const{output:n}=this.config,t=await this.createAsset(e),a=await this.bundleUpdateChunk(t);await s().writeFile(r().join(n,"hot-update.js"),a)}async build(){const{entry:e,output:n,filename:t}=this.config,a=await this.createGraph(e),o=this.bundleInitialChunk(a[0]);await s().writeFile(r().join(n,t),o);const i=a.slice(1).map((async e=>{const t=e[0].id.replace(/\//g,"-");await s().writeFile(r().join(n,t),this.bundleNonInitialChunk(e))}));await Promise.all(i)}async rebuild(e){this.assetMap.delete(e),await this.build()}};var c=exports;for(var u in n)c[u]=n[u];n.__esModule&&Object.defineProperty(c,"__esModule",{value:!0})})();